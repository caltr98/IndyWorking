package OldTests;
//WARNING: un-tested!it can be used as a reference for revocation
import IndyLibraries.*;
import OldTests.sideTestIndy;
import org.hyperledger.indy.sdk.IndyException;
import org.hyperledger.indy.sdk.anoncreds.Anoncreds;
import org.hyperledger.indy.sdk.ledger.Ledger;
import org.hyperledger.indy.sdk.ledger.LedgerResults;
import org.hyperledger.indy.sdk.pool.Pool;
import org.hyperledger.indy.sdk.wallet.Wallet;
import org.json.JSONObject;

import javax.crypto.NoSuchPaddingException;
import java.io.File;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.ExecutionException;

public class MainTestIndy {
    //Similar to sideTestIndy but this time Spotify/External service issues credentials too.

    public static void main(String[] args){
        String poolName="INDYSCANPOOL";
        //In Indy pre generated genesis transaction there are two DID for a Default Steward and a Default IndyLibraries.Trustee
        //which can be generated by those two Seeds.
        String stewardSeed = "000000000000000000000000Steward1";
        String trusteeSeed= "000000000000000000000000Trustee1";
        Pool pool=null;
        File agentsFile=new File("./agentsFile.json");
        JSONUserCredentialStorage jsonStoredCred=null;
        try {
            jsonStoredCred= new JSONUserCredentialStorage(agentsFile);
        } catch (NoSuchPaddingException | NoSuchAlgorithmException | IOException e) {
            e.printStackTrace();
        }
        try {
            Pool.setProtocolVersion(2).get();

            //1. Create and Open Pool
             //poolName = IndyLibraries.PoolUtils.createPoolLedgerConfig();

            //Pool.createPoolLedgerConfig(poolName,"{}").get();
            pool = Pool.openPoolLedger(poolName, "{}").get();
        } catch (InterruptedException | ExecutionException | IndyException e) {
            e.printStackTrace();
        }
        try {
            jsonStoredCred= new JSONUserCredentialStorage(agentsFile);
        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("Recupero credenziali Steward");
        Trustee Admin = new Trustee(pool,"trustee",jsonStoredCred);
        Admin.CreateWallet("trusteewallet","pass");
        Admin.OpenWallet("trusteewallet","pass");
        Admin.createDID(trusteeSeed);
        System.out.println("IndyLibraries.Trustee DID: "+ Admin.getMainDID().didName+" "+
                "IndyLibraries.Trustee VerKey: "+Admin.getMainDID().didVerKey);

        StewardAgent Ministero = new StewardAgent(pool,"ministero",jsonStoredCred);
        Ministero.CreateWallet("stewardwallet","pass");
        Ministero.OpenWallet("stewardwallet","pass");
        Ministero.createDID();//this time it's another steward
        System.out.println("Steward DID: "+ Ministero.getMainDID().didName+" "+
                "Steward VerKey: "+Ministero.getMainDID().didVerKey);

        boolean feedback=Admin.assignStewardRole(Ministero.mainDID);

        Endorser University = new Endorser(pool,"UNIPI",jsonStoredCred);
        //University.CreateWallet("endorserwallet","abcd");
        University.OpenWallet("endorserwallet","abcd");
        University.createDID();

        feedback=Ministero.assignEndorserRole(University.mainDID,true);
        System.out.println("ruolo di Steward assegnato?"+feedback);
        System.out.println("\nUniversity DID: "+ University.getMainDID().didName+" "+
                "University VerKey:"+University.getMainDID().didVerKey);

        String[] attributesForSchema={"name","surname","matricola"};
        SchemaStructure StudentIdentitySchema=University.
                publishschema("StudentIdentity","1.0",attributesForSchema);

        System.out.println("Schema credenziali di ID: "+ StudentIdentitySchema.schemaId+": \n"+new JSONObject(StudentIdentitySchema.schemaJson).toString(4) + "\n");

        CredDefStructure credDefStudIdent=
                University.IssuerCreateStoreAndPublishCredDef("TAG2",true,
                StudentIdentitySchema.schemaId);

        System.out.println("Credential Definition creata: "+credDefStudIdent.credDefId+":\n"+new JSONObject(credDefStudIdent.credDefJson).toString(4) + "\n");

        Agent Studente = new Agent(pool,"Alice",jsonStoredCred);
        //necessario avere un wallet nuovo ad ogni esecuzione al momento

        //Studente.CreateWallet("4-AgentWallet411","passWORD");
        Studente.OpenWallet("4-AgentWallet411","passWORD");

        Studente.createDID();
        Studente.createMasterSecret("0e6a6869-f288-491e-977c-d77ea1c348f6");

        System.out.println("\nAlice DID: "+ Studente.getMainDID().didName+" "+
                "Alice VerKey"+Studente.getMainDID().didVerKey);

        CredOfferStructure credOfferToStudent=University.returnCredentialOffer(credDefStudIdent.credDefId);

        System.out.println("credential offer: \n"+new JSONObject(credOfferToStudent.credOffer).toString(4)+"\n");
        CredRequestStructure credRequestStructure=Studente.returnproverCreateCredentialRequest(credOfferToStudent);

        University.createDID();
        University.createDID();//non è che creare più did sballa il wallet?
        CreateCredentialResult credentialREA=University.returnIssuerCreateCredentialNonRevocable
                (attributesForSchema,new String[]{"Alice","Alic","55812"},
                credOfferToStudent.credOffer, credRequestStructure.credReqJson
                );
        System.out.println("rea"+ credentialREA.credentialJson);
        String credential=credentialREA.credentialJson;
        String credentialStore;
        credentialStore=Studente.storeCredentialInWallet(null,credOfferToStudent.credDef.credDefId,credRequestStructure.credReqMetadataJson,
                credential,credOfferToStudent.credDef.credDefJson,null);

        System.out.println("credenziale rilasciata: \n"+new JSONObject(credential).toString(4)+"\n");
        //in realtà un Verifier può anche non essere un endorser ma un utente normale con solo permessi di lettura
        System.out.println("Cred Stored in Wallet Reference "+ credentialStore);
        Endorser Spotify = new Endorser(pool,"Spotify",jsonStoredCred);
        Spotify.CreateWallet("SpotifyWallet","SpassWORD");
        Spotify.OpenWallet("SpotifyWallet","SpassWORD");
        Spotify.createDID();

        feedback=Ministero.assignEndorserRole(Spotify.mainDID ,true);
        String proofReqbody=Spotify.returnVerifierGenerateSimpleProofRequest("proof_req_1",
                "1.0",attributesForSchema,new String []{StudentIdentitySchema.schemaId,StudentIdentitySchema.schemaId,StudentIdentitySchema.schemaId}
        ,new String[]{credDefStudIdent.credDefId,credDefStudIdent.credDefId,credDefStudIdent.credDefId});
        System.out.println(proofReqbody);
        ProofCreationExtra proof=Studente.returnProverSearchAttrAndCreateProofSimple(proofReqbody,attributesForSchema,
                null);

        System.out.println("Proof Creata:"+ proof.proofJson);
        System.out.println("Proof schemas"+proof.schemas);
        System.out.println("Proof CredDef"+proof.credentialDefs);
        System.out.println(credDefStudIdent);
        System.out.println("proof is right? "+
                Spotify.returnVerifierVerifyProofNOREVOCATION(proof.proofRequestJson,proof.proofJson,proof.schemas,
                        proof.credentialDefs));
        try {
            jsonStoredCred.makeBackup();
        } catch (IOException e) {
            e.printStackTrace();
        }
            //University.createRevocationRegistry("CL_ACCUM","TAGREV1",
                   // credDefStudIdent.credDefId,"ISSUANCE_ON_DEMAND","5");




        //PART 2: CREA uno schema e una proof request basata questa volta sui predicati
        String [] attributes2=new String[]{"NumberOfmonths"};
        SchemaStructure SubscriptionSchema=Spotify.publishschema("SubscriptionSchema","1.0",new String[]{"NumberOfmonths"});

        System.out.println("Schema credenziali di ID: "+ SubscriptionSchema.schemaId+": \n"+new JSONObject(SubscriptionSchema.schemaJson).toString(4) + "\n");

        CredDefStructure credDefSubscription=
                Spotify.IssuerCreateStoreAndPublishCredDef("TAG1",true,
                        SubscriptionSchema.schemaId);

        System.out.println("Credential Definition creata: "+credDefSubscription.credDefId+":\n"+new JSONObject(credDefSubscription.credDefJson).toString(4) + "\n");
        RevocationRegistryObject revRegSub=Spotify.createRevocationRegistry("CL_ACCUM","TAGREV21",
                credDefSubscription.credDefId,"ISSUANCE_ON_DEMAND","5");

        System.out.println("Let's see a bit of rev reg, revocation registry definition");
        System.out.println("revocation def "+Spotify.publishRevocationRegistryDefinition(revRegSub));


        System.out.println("rev ENTRY"+Spotify.revocationRegistryEntryPublishDelta(revRegSub));


        CredOfferStructure credOfferToSubscriber=Spotify.returnCredentialOffer(credDefSubscription.credDefId);
        CredRequestStructure credRequestStructSubscription=Studente.returnproverCreateCredentialRequest(credOfferToSubscriber);
        CreateCredentialResult credentialSubscription=Spotify.returnIssuerCreateCredential(attributes2,new String[]{"18"},
                credOfferToSubscriber.credOffer, credRequestStructSubscription.credReqJson,revRegSub
        );
        System.out.println("createdCredential ::: "+credentialSubscription.credentialJson);
        String credentialSubscriptionStore;
        //find a way to pass revRegDef to prover TODO
        credentialSubscriptionStore=Studente.storeCredentialInWallet(null,credOfferToSubscriber.credDef.credDefId,credRequestStructSubscription.credReqMetadataJson,
                credentialSubscription.credentialJson,credOfferToSubscriber.credDef.credDefJson,revRegSub.revRegDefJson);
        System.out.println("credenziale: "+credentialSubscription.credentialJson);
        Spotify.revocationRegistryEntryPublishDelta(revRegSub);
        Spotify.getRevocRegReqGetAccum(revRegSub, sideTestIndy.getUnixTimeStamp());
        Spotify.revocationRegistryEntryPublishDelta2(revRegSub.revRegId,
                credentialSubscription.revocRegDeltaJson
                );
        Spotify.getRevocRegReqGetAccum(revRegSub,sideTestIndy.getUnixTimeStamp());
        Spotify.IssuerRevokeCredentialAndPublish(revRegSub,credentialSubscription.revocId);

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String accumdeltas=Spotify.getRevocRegReqGetAccum(revRegSub,sideTestIndy.getUnixTimeStamp());

        /*

        String deltaRekedExample=Spotify.IssuerRevokeCredential(revRegSub,credentialSubscription.revocId);
        String revokStatE=Spotify.createRevocationState(revRegSub,credentialSubscription.revocRegDeltaJson,System.currentTimeMillis(),
               credentialSubscription.revocId);
        System.out.println("revocation state " +revokStatE);

        System.out.println("revocation registry information about operation " + Spotify.publishRevocationRegistryEntry(revRegSub,deltaRekedExample));
        System.out.println("delta REVOKED EXAMPLE"+ new JSONObject(deltaRekedExample).toString());

        int to = (int) (new Date().getTime()/1000) + 100;

        IndyLibraries.RevocationRegistryDelta anotherDelta = Spotify.getRevocationRegistryDeltaSpecificTimeFrame(revRegSub,-1L,Long.valueOf(to));

        System.out.println("anotherDELTAGOTINANOTHERWAY"+anotherDelta.objectJson+"\n"+anotherDelta.id + "timestamp"
        +" "+anotherDelta.timestamp);
        String mergeofAnotherANDRevok= Spotify.IssuerMERGERevokeCredential(deltaRekedExample,anotherDelta.objectJson);

        System.out.println("merger DELTA"+mergeofAnotherANDRevok);
*/
        long timestamp= sideTestIndy.getUnixTimeStamp();
        JSONObject predicateRequest = Spotify.generatePredicatesInfoForProofRequest("NumberOfmonths",">=","1",
                SubscriptionSchema.schemaId,Spotify.mainDID.didName,null,null,
                Spotify.mainDID.didName,credDefSubscription.credDefId,revRegSub.revRegId,
                timestamp,timestamp);





        String proofRequestOfPredicate = Spotify.returnVerifierGenerateProofRequest("proofOfSubscription",
                "1.0",null,null,new JSONObject[]{predicateRequest},
                timestamp,timestamp);
        //System.out.println("new proof request "+proofRequestOfPredicate);
        ProofAttributesFetched AttributeForproofForSubscription=Studente.returnProverSearchAttrForProof(proofRequestOfPredicate,null);
        System.out.println("numbero di proof: "+AttributeForproofForSubscription.AttrcredDefIDs.size() +" predicates "+
                AttributeForproofForSubscription.predicatestoReferenceList.size() + "little lenght to predicate cred def id"+AttributeForproofForSubscription.PredicatescredDefIDs.size());
        ProofCreationExtra createdProof = Studente.proverCreateProof(AttributeForproofForSubscription,proofRequestOfPredicate,null,sideTestIndy.getUnixTimeStamp() , revRegSub.blobStorageReaderHandle);
        /*String getRevocationThings = Studente.proverGetRevocationStateFORPROOF(revRegSub,
                System.currentTimeMillis(),credentialSubscription.revocId);
        //System.out.println(createdProof.proofJson);
        JSONObject revocthinsregs= new JSONObject();
        JSONObject revocRegDefs = new JSONObject();
        long time=System.currentTimeMillis();
        revocRegDefs.put(revRegSub.revRegId, new JSONObject(Studente.getRevocationDefinition(revRegSub)));


        String getDeltaForProof= Studente.getDeltaForProof(revRegSub,time);
        revocthinsregs.put(revRegSub.revRegId, new JSONObject().put(Long.toString(time), new JSONObject(getDeltaForProof)));

        System.out.println(revocthinsregs.toString(4)+"\n"+revocRegDefs.toString(4));
        System.out.println("Proof Verification "+

                Spotify.returnVerifierVerifyProofNOREVOCATION(proofRequestOfPredicate,createdProof.proofJson,createdProof.schemas,
                        createdProof.credentialDefs));
        */
        try {
            String request, response;
            String didTrustAnchor = Studente.mainDID.didName;
            String revRegDefId = revRegSub.revRegId;
            Wallet myWallet = Studente.mainWallet;
            Pool myPool = Studente.poolConnection;
            JSONObject revocRegDefs = new JSONObject();
            request = Ledger.buildGetRevocRegDefRequest(didTrustAnchor, revRegDefId).get();
            response = Ledger.signAndSubmitRequest(myPool, myWallet, didTrustAnchor, request).get();
            LedgerResults.ParseResponseResult parseResult = Ledger.parseGetRevocRegDefResponse(response).get();
            String revRegDefReadFromLedgerByVerifier = parseResult.getObjectJson();
            revocRegDefs.put(revRegDefId, new JSONObject(revRegDefReadFromLedgerByVerifier));
            System.out.println("Prover has build his own Revocation Defs:\n" + revocRegDefs + "\n");

            // the prover creates his own revocation states. Herefor he uses the timestamps from the
            // original proofrequest
            JSONObject revocRegs = new JSONObject();
            long from = timestamp;
            long to = timestamp;

            request = Ledger.buildGetRevocRegDeltaRequest(didTrustAnchor, revRegDefId, from, to).get();
            response = Ledger.signAndSubmitRequest(myPool, myWallet, didTrustAnchor, request).get();
            System.out.println("Prover has read the revoc delta for interval from: " + from + "to: " + to + " response from ledger \n" + response + "\n");
            LedgerResults.ParseRegistryResponseResult parseRegRespResult = Ledger.parseGetRevocRegDeltaResponse(response).get();
            String proverReadDeltaFromLedger = parseRegRespResult.getObjectJson();
            System.out.println("Prover has read the revoc delta for interval from: " + from + "to: " + to + "\n" + proverReadDeltaFromLedger + "\n");

            /*
             * revoc delta for current timestamp
             */
            long time = sideTestIndy.getUnixTimeStamp();
            request = Ledger.buildGetRevocRegDeltaRequest(didTrustAnchor, revRegDefId, time, time).get();
            response = Ledger.signAndSubmitRequest(myPool, myWallet, didTrustAnchor, request).get();
            System.out.println("Prover has read the revoc delta for interval from: " + time + "to: " + time + " response from ledger \n" + response + "\n");
            parseRegRespResult = Ledger.parseGetRevocRegDeltaResponse(response).get();
            proverReadDeltaFromLedger = parseRegRespResult.getObjectJson();
            System.out.println("Prover has read the revoc delta for interval from: " + time + "to: " + time + "\n" + proverReadDeltaFromLedger + "\n");
            /*
             *
             */


            revocRegs.put(revRegDefId, new JSONObject().put(Long.toString(from), new JSONObject(proverReadDeltaFromLedger)));
            System.out.println("Prover has build his own Revocation States:\n" + revocRegDefs.toString(4) + "\n");


		/*
		request = Ledger.buildGetRevocRegRequest(didProver, revRegDefId, proverTimestamp).get();
		response = Ledger.submitRequest(myPool, request).get();
		System.out.println("Read RevocReg from Ledger response:\n" + response + "\n");


		request = Ledger.buildGetRevocRegRequest(didProver, revRegDefId, getUnixTimeStamp()).get();
		response = Ledger.submitRequest(myPool, request).get();
		System.out.println("Read RevocReg from Ledger response:\n" + response + "\n");
		*/

        System.out.println("printing all the way:"+
                "\n createdProof.request 1: "+createdProof.proofRequestJson
                +"\n createdProof proof 2 :" + createdProof.proofJson
                +"\n createdProof proof 3:" + createdProof.schemas+
                "+\n created proof 4:"+ createdProof.credentialDefs+
                "\n revocregdegs 5: "+ revocRegDefs +
                "\n revocReg 6:"+ revocRegs);
            Boolean verifyResult = Anoncreds.verifierVerifyProof(createdProof.proofRequestJson, createdProof.proofJson, createdProof.schemas,
                    createdProof.credentialDefs, revocRegDefs.toString(), revocRegs.toString()).get();
            System.out.println("The proof result ist: " + verifyResult);

        } catch (IndyException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("ending");
        //1)ProofRequest con i predicati e il campo non revoked
        //2)verifica della proof request con campi misti da due schema diversi
        //3) implementare revocazione
        //4)check della proof dopo la revocazione
        //5)profit ?*/
    }
}
